"""Runtime protection engine — unified detector orchestration.

Connects the five runtime detectors, OTel trace ingestion, and the alert
dispatcher into a single protection pipeline. Activated via the API
(``POST /v1/protect/start``) or CLI (``agent-bom protect``).
"""

from __future__ import annotations

import logging
from dataclasses import dataclass
from datetime import datetime, timezone

from agent_bom.alerts.dispatcher import AlertDispatcher
from agent_bom.otel_ingest import parse_otel_traces
from agent_bom.runtime.detectors import (
    ArgumentAnalyzer,
    CredentialLeakDetector,
    RateLimitTracker,
    SequenceAnalyzer,
    ToolDriftDetector,
)

logger = logging.getLogger(__name__)


@dataclass
class ProtectionStats:
    """Lifetime statistics for a protection engine session."""

    started_at: str = ""
    traces_processed: int = 0
    tool_calls_analyzed: int = 0
    alerts_generated: int = 0
    detectors_active: int = 5


class ProtectionEngine:
    """Orchestrates runtime detectors with OTel ingestion and alert dispatch.

    Typical lifecycle::

        engine = ProtectionEngine(dispatcher)
        engine.start()
        # ... receive OTel traces or individual tool calls ...
        alerts = await engine.process_trace(otel_data)
        alerts = await engine.process_tool_call("read_file", {"path": "/etc/passwd"})
        engine.stop()
    """

    def __init__(self, dispatcher: AlertDispatcher | None = None) -> None:
        self.drift_detector = ToolDriftDetector()
        self.arg_analyzer = ArgumentAnalyzer()
        self.cred_detector = CredentialLeakDetector()
        self.rate_tracker = RateLimitTracker()
        self.seq_analyzer = SequenceAnalyzer()
        self.dispatcher = dispatcher or AlertDispatcher()
        self._active = False
        self._stats = ProtectionStats()

    def start(self) -> None:
        """Activate protection engine."""
        self._active = True
        self._stats.started_at = datetime.now(timezone.utc).isoformat()
        logger.info("Protection engine started")

    def stop(self) -> None:
        """Deactivate protection engine."""
        self._active = False
        logger.info("Protection engine stopped")

    @property
    def active(self) -> bool:
        return self._active

    def status(self) -> dict:
        """Return current engine status and statistics."""
        return {
            "active": self._active,
            "started_at": self._stats.started_at,
            "traces_processed": self._stats.traces_processed,
            "tool_calls_analyzed": self._stats.tool_calls_analyzed,
            "alerts_generated": self._stats.alerts_generated,
            "detectors": [
                "ToolDriftDetector",
                "ArgumentAnalyzer",
                "CredentialLeakDetector",
                "RateLimitTracker",
                "SequenceAnalyzer",
            ],
            "detectors_active": self._stats.detectors_active,
        }

    async def process_trace(self, trace_data: dict) -> list[dict]:
        """Process an OTel trace export through all detectors.

        Args:
            trace_data: OTel JSON export (``resourceSpans`` format).

        Returns:
            List of alert dicts generated by detectors.
        """
        traces = parse_otel_traces(trace_data)
        self._stats.traces_processed += len(traces)

        all_alerts: list[dict] = []
        for trace in traces:
            alerts = await self.process_tool_call(trace.tool_name, trace.parameters or {})
            all_alerts.extend(alerts)

        return all_alerts

    async def process_tool_call(self, tool_name: str, arguments: dict) -> list[dict]:
        """Analyze a single tool call through all detectors.

        Args:
            tool_name: MCP tool being invoked.
            arguments: Tool call arguments.

        Returns:
            List of alert dicts for any findings.
        """
        self._stats.tool_calls_analyzed += 1
        all_alerts: list[dict] = []

        # Argument analysis — shell injection, path traversal, etc.
        arg_alerts = self.arg_analyzer.check(tool_name, arguments)
        all_alerts.extend(a.to_dict() for a in arg_alerts)

        # Rate limiting
        rate_alerts = self.rate_tracker.record(tool_name)
        all_alerts.extend(a.to_dict() for a in rate_alerts)

        # Sequence analysis — suspicious multi-step patterns
        seq_alerts = self.seq_analyzer.record(tool_name)
        all_alerts.extend(a.to_dict() for a in seq_alerts)

        # Dispatch all alerts
        for alert_dict in all_alerts:
            await self.dispatcher.dispatch(alert_dict)

        self._stats.alerts_generated += len(all_alerts)
        return all_alerts

    async def process_tool_response(self, tool_name: str, response_text: str) -> list[dict]:
        """Check a tool response for credential leaks.

        Args:
            tool_name: MCP tool that produced the response.
            response_text: Response text to analyze.

        Returns:
            List of alert dicts for any credential leaks detected.
        """
        cred_alerts = self.cred_detector.check(tool_name, response_text)
        all_alerts = [a.to_dict() for a in cred_alerts]

        for alert_dict in all_alerts:
            await self.dispatcher.dispatch(alert_dict)

        self._stats.alerts_generated += len(all_alerts)
        return all_alerts

    async def check_tool_drift(self, current_tools: list[str]) -> list[dict]:
        """Check for tool drift (new tools appearing after baseline).

        Args:
            current_tools: Current tool names from tools/list.

        Returns:
            List of alert dicts for any drift detected.
        """
        drift_alerts = self.drift_detector.check(current_tools)
        all_alerts = [a.to_dict() for a in drift_alerts]

        for alert_dict in all_alerts:
            await self.dispatcher.dispatch(alert_dict)

        self._stats.alerts_generated += len(all_alerts)
        return all_alerts
